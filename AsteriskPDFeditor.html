<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro PDF Editor & Linker Tool</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-header: #333333;
            --accent: #007acc;
            --accent-hover: #0062a3;
            --text-main: #d4d4d4;
            --text-muted: #aaaaaa;
            --border: #3e3e42;
            --canvas-bg: #525659;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            height: 55px;
            background-color: var(--bg-header);
            display: flex;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border);
            justify-content: space-between;
            z-index: 10;
            user-select: none;
            flex-wrap: wrap;
        }

        .brand { font-weight: bold; font-size: 1.1rem; color: #fff; margin-right: 20px; }
        
        .toolbar-group { display: flex; gap: 5px; align-items: center; margin-right: 15px; }
        
        button {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        button:hover { background-color: var(--border); }
        button.active { background-color: var(--accent); color: white; border-color: var(--accent); }
        button.primary { background-color: var(--accent); border-color: var(--accent); color: white; }
        button.primary:hover { background-color: var(--accent-hover); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .separator { width: 1px; height: 24px; background: var(--border); margin: 0 8px; }

        /* Mode Switch */
        .mode-switch-container {
            display: flex;
            align-items: center;
            background: var(--bg-panel);
            border-radius: 4px;
            padding: 2px;
            margin-right: 15px;
        }
        .mode-btn {
            padding: 4px 10px;
            border: none;
            background: transparent;
            color: #888;
            font-size: 0.85rem;
            border-radius: 2px;
        }
        .mode-btn.active {
            background: var(--accent);
            color: white;
            font-weight: bold;
        }

        /* --- Main Layout --- */
        main {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 200px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: margin 0.3s;
        }
        
        .sidebar-header { padding: 10px; font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        
        .page-thumbnail {
            margin: 5px 10px;
            padding: 5px;
            border: 1px solid transparent;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.2s;
        }
        .page-thumbnail:hover { background-color: var(--border); }
        .page-thumbnail.active { background-color: #37373d; border: 1px solid var(--accent); }
        .page-thumbnail canvas { max-width: 100%; height: auto; border: 1px solid #555; background: white; }
        .page-number { font-size: 0.8rem; margin-top: 4px; color: var(--text-muted); }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            background-color: var(--bg-panel);
            overflow: auto;
            display: flex;
            justify-content: center;
            padding: 40px;
            position: relative;
            user-select: none; 
        }

        /* --- Editor Container (Single Page) --- */
        #editor-container {
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: transform 0.2s;
            /* CRITICAL: Ensures it captures events on children when needed */
            touch-action: none;
        }
        .viewer-active #editor-container { display: none; }

        /* --- Viewer Container (Continuous Scroll) --- */
        #viewer-container {
            display: none;
            flex-direction: column;
            align-items: center;
            padding-bottom: 40px;
        }
        .viewer-active #viewer-container { display: flex; }
        .viewer-active .workspace {
            justify-content: flex-start;
            padding: 20px;
            background-color: var(--canvas-bg);
        }

        .viewer-page-wrap {
            position: relative;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Canvases */
        .pdf-canvas {
            display: block;
            background-color: white;
            pointer-events: none; /* Canvas is just background image */
        }

        #annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Clicks pass through to elements or container */
            overflow: hidden;
        }
        #annotation-layer.tool-active {
            pointer-events: auto; 
            cursor: crosshair;
        }
        #annotation-layer.tool-active[data-tool="text"] { cursor: text; }

        /* --- Marquee Selection Box (Clean Slate) --- */
        #marquee-box {
            position: absolute;
            border: 1px dashed var(--accent);
            background: rgba(0, 122, 204, 0.2);
            display: none;
            pointer-events: none; /* Let clicks pass through it */
            z-index: 2000; /* Above everything */
        }

        /* --- Interactive Elements --- */
        .pdf-element {
            position: absolute;
            pointer-events: auto;
            user-select: none;
            box-sizing: border-box;
            transition: outline 0.1s;
        }

        .pdf-element.group-selected { outline: 2px dashed var(--accent); }
        .pdf-element.selected { outline: 2px solid var(--accent); z-index: 1000; }
        .pdf-element.marquee-highlight { outline: 2px dashed #00ff00; z-index: 950; }

        .el-text { 
            background: transparent; 
            white-space: pre-wrap;
            overflow: hidden;
            line-height: 1.2;
            padding: 2px;
            color: inherit;
            cursor: text;
        }
        .el-text[contenteditable="true"] { outline: none; }
        .editor-active .el-text:hover { border: 1px dashed #ccc; }
        .editor-active .el-text.selected:hover { border: none; }

        .el-link {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .editor-active .el-link::after { content: 'ðŸ”—'; opacity: 0.5; }
        .el-link.has-content::after { display: none; }
        
        .viewer-active .el-link { cursor: pointer; }

        /* --- Resize Handles --- */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent);
            border: 1px solid white;
            border-radius: 50%;
            z-index: 1001;
            display: none; 
        }
        .pdf-element.selected .resize-handle { display: block; }
        .pdf-element.group-selected .resize-handle { display: none; }

        .rh-nw { top: -5px; left: -5px; cursor: nw-resize; }
        .rh-ne { top: -5px; right: -5px; cursor: ne-resize; }
        .rh-sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .rh-se { bottom: -5px; right: -5px; cursor: se-resize; }

        /* Viewer Mode Global Styles */
        body.viewer-active #tool-group { display: none; }
        body.viewer-active .resize-handle { display: none !important; }
        body.viewer-active .pdf-element.selected, 
        body.viewer-active .pdf-element.group-selected,
        body.viewer-active .pdf-element.marquee-highlight { outline: none !important; }
        body.viewer-active .ghost-border { border: none !important; background: transparent !important; }
        body.viewer-active .properties-panel { display: none !important; }
        body.viewer-active .el-text { pointer-events: none; }

        /* --- Properties Panel --- */
        .properties-panel {
            width: 260px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 15px;
            overflow-y: auto;
            display: none; 
            flex-shrink: 0;
        }
        .properties-panel.visible { display: block; }
        
        .prop-group { margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom:10px; }
        .prop-label { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 5px; display: block; }
        .prop-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
        
        input[type="text"], input[type="number"], input[type="color"], select, textarea {
            width: 100%;
            background: var(--bg-header);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 5px;
            border-radius: 3px;
        }
        input[type="color"] { height: 30px; padding: 0 2px; }
        
        .btn-delete { width: 100%; background: #a1260d; border-color: #802009; color: white; margin-top: 10px;}
        .btn-delete:hover { background: #c83618; }

        .info-msg { font-size:0.75rem; color: #888; font-style:italic; margin-top:5px; }

        /* --- Toast --- */
        .toast {
            position: fixed; bottom: 20px; right: 20px;
            background: #333; color: #fff; padding: 12px 20px;
            border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translateY(100px); transition: transform 0.3s;
            z-index: 9999; border-left: 4px solid var(--accent);
        }
        .toast.show { transform: translateY(0); }

        /* --- Loader --- */
        .loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 10000; flex-direction: column;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.1); width: 40px; height: 40px;
            border-radius: 50%; border-left-color: var(--accent);
            animation: spin 1s linear infinite; margin-bottom: 10px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .hidden { display: none !important; }

        .ghost-border { border: 1px dashed var(--accent) !important; background: rgba(0, 122, 204, 0.1) !important; }
    </style>
</head>
<body class="editor-active">

    <div id="loader" class="loader hidden">
        <div class="spinner"></div>
        <div id="loader-text">Processing...</div>
    </div>

    <header>
        <div style="display:flex; align-items:center;">
            <div class="brand"><i class="fa-solid fa-file-pdf"></i> PDF Editor</div>
            
            <!-- Mode Switch -->
            <div class="mode-switch-container">
                <button class="mode-btn active" id="mode-editor" onclick="setMode('editor')">Editor</button>
                <button class="mode-btn" id="mode-viewer" onclick="setMode('viewer')">Viewer</button>
            </div>

            <div class="toolbar-group" id="file-group">
                <button class="primary" id="btn-upload"><i class="fa-solid fa-upload"></i> Upload PDF</button>
                <input type="file" id="file-input" accept=".pdf" style="display:none;">
            </div>

            <div class="toolbar-group" id="tool-group">
                <button class="tool-btn active" data-tool="cursor" title="Select / Move (V)"><i class="fa-solid fa-arrow-pointer"></i></button>
                <button class="tool-btn" data-tool="text" title="Add Text (T)"><i class="fa-solid fa-font"></i></button>
                <button class="tool-btn" data-tool="rect" title="Add Rectangle (R)"><i class="fa-regular fa-square"></i></button>
                <button class="tool-btn" data-tool="highlight" title="Highlighter (H)"><i class="fa-solid fa-highlighter"></i></button>
                <button class="tool-btn" data-tool="link" title="Add Hyperlink (L)"><i class="fa-solid fa-link"></i></button>
            </div>

            <div class="toolbar-group" id="history-group">
                <button id="btn-undo" disabled title="Undo (Ctrl+Z)"><i class="fa-solid fa-rotate-left"></i></button>
                <button id="btn-redo" disabled title="Redo (Ctrl+Shift+Z)"><i class="fa-solid fa-rotate-right"></i></button>
            </div>

            <div class="separator"></div>
            <span id="page-indicator" style="font-size: 0.9rem; color: #aaa;">No PDF</span>
        </div>

        <div class="toolbar-group" id="export-group">
            <button id="btn-export"><i class="fa-solid fa-download"></i> Export PDF</button>
        </div>
    </header>

    <main>
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">Pages</div>
            <div id="thumbnails-container">
                <div style="padding:20px; text-align:center; color:#666; font-size:0.8rem;">Upload PDF</div>
            </div>
        </div>

        <div class="workspace" id="workspace">
            <!-- Editor Mode: Single Page -->
            <div id="editor-container">
                <canvas id="the-canvas" class="pdf-canvas"></canvas>
                <div id="annotation-layer"></div>
                <div id="marquee-box"></div>
            </div>
            
            <!-- Viewer Mode: Continuous Scroll -->
            <div id="viewer-container">
                <!-- Pages injected here -->
            </div>
        </div>

        <div class="properties-panel" id="properties-panel">
            <div class="sidebar-header">Properties</div>
            <div id="props-content">
                <div id="multi-select-msg" style="display:none; color:#888; font-style:italic; margin-bottom:15px;">
                    Multiple items selected.
                </div>

                <!-- Shared Props -->
                <div class="prop-group" id="group-pos">
                    <span class="prop-label">Position</span>
                    <div class="prop-row">
                        <input type="number" id="prop-x" placeholder="X">
                        <input type="number" id="prop-y" placeholder="Y">
                    </div>
                </div>
                
                <div class="prop-group" id="group-dim">
                    <span class="prop-label">Dimensions</span>
                    <div class="prop-row">
                        <input type="number" id="prop-w" placeholder="W">
                        <input type="number" id="prop-h" placeholder="H">
                    </div>
                </div>

                <!-- Style Props -->
                <div class="prop-group" id="group-color">
                    <span class="prop-label">Color / Fill</span>
                    <div class="prop-row">
                        <input type="color" id="prop-color" value="#ff0000">
                        <input type="range" id="prop-opacity" min="0" max="1" step="0.1" value="1" title="Fill Opacity">
                    </div>
                </div>

                <div class="prop-group" id="group-border">
                    <span class="prop-label">Border</span>
                    <div class="prop-row">
                        <input type="number" id="prop-border-width" value="0" min="0">
                        <input type="color" id="prop-border-color" value="#000000">
                    </div>
                </div>

                <!-- Text Specific -->
                <div class="prop-group" id="group-text" style="display:none;">
                    <span class="prop-label">Text Content (HTML supported)</span>
                    <textarea id="prop-text" rows="3"></textarea>
                    <div class="prop-row">
                        <label>Size: <input type="number" id="prop-font-size" value="16" style="width:60px"> px</label>
                    </div>
                </div>

                <!-- Link Specific -->
                <div class="prop-group" id="group-link" style="display:none;">
                    <span class="prop-label">Link Type</span>
                    <select id="link-type-selector">
                        <option value="url">External URL</option>
                        <option value="page">Internal Page Jump</option>
                    </select>

                    <div id="link-url-container">
                        <span class="prop-label" style="margin-top:5px;">Target URL</span>
                        <input type="text" id="prop-link-url" placeholder="https://example.com">
                    </div>

                    <div id="link-page-container" style="display:none;">
                        <span class="prop-label" style="margin-top:5px;">Go to Page Number</span>
                        <input type="number" id="prop-link-page" placeholder="e.g. 45">
                        <div class="info-msg">Enter the page number this box should jump to.</div>
                    </div>
                </div>

                <button class="btn-delete" id="btn-delete-element"><i class="fa-solid fa-trash"></i> Delete Element(s)</button>
            </div>
        </div>
    </main>

    <div id="toast" class="toast">Message</div>

    <script>
        // --- Global State ---
        const state = {
            pdfDoc: null,
            currentPage: 1,
            scale: 1.5,
            mode: 'editor', 
            tool: 'cursor',
            elements: {}, 
            selectedIds: [], 
            isDragging: false,
            isResizing: false,
            isMarquee: false,
            resizeDir: null, 
            dragStart: { x: 0, y: 0 },
            initialEls: {}, 
            rawPdfBytes: null,
            undoStack: [],
            redoStack: []
        };

        // --- DOM ---
        const ui = {
            fileInput: document.getElementById('file-input'),
            btnUpload: document.getElementById('btn-upload'),
            btnExport: document.getElementById('btn-export'),
            btnUndo: document.getElementById('btn-undo'),
            btnRedo: document.getElementById('btn-redo'),
            toolBtns: document.querySelectorAll('.tool-btn'),
            canvas: document.getElementById('the-canvas'),
            editorContainer: document.getElementById('editor-container'),
            viewerContainer: document.getElementById('viewer-container'),
            annotationLayer: document.getElementById('annotation-layer'),
            marqueeBox: document.getElementById('marquee-box'),
            sidebar: document.getElementById('thumbnails-container'),
            pageIndicator: document.getElementById('page-indicator'),
            propertiesPanel: document.getElementById('properties-panel'),
            multiMsg: document.getElementById('multi-select-msg'),
            loader: document.getElementById('loader'),
            toast: document.getElementById('toast'),
            propInputs: {
                x: document.getElementById('prop-x'), y: document.getElementById('prop-y'),
                w: document.getElementById('prop-w'), h: document.getElementById('prop-h'),
                color: document.getElementById('prop-color'),
                opacity: document.getElementById('prop-opacity'),
                borderWidth: document.getElementById('prop-border-width'),
                borderColor: document.getElementById('prop-border-color'),
                text: document.getElementById('prop-text'),
                fontSize: document.getElementById('prop-font-size'),
                linkUrl: document.getElementById('prop-link-url'),
                linkPage: document.getElementById('prop-link-page'),
                linkType: document.getElementById('link-type-selector')
            },
            groups: {
                color: document.getElementById('group-color'),
                border: document.getElementById('group-border'),
                text: document.getElementById('group-text'),
                link: document.getElementById('group-link'),
                pos: document.getElementById('group-pos'),
                dim: document.getElementById('group-dim'),
                urlCont: document.getElementById('link-url-container'),
                pageCont: document.getElementById('link-page-container')
            }
        };

        // --- Init ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Mode Switching
        window.setMode = async (mode) => {
            state.mode = mode;
            document.getElementById('mode-editor').classList.toggle('active', mode === 'editor');
            document.getElementById('mode-viewer').classList.toggle('active', mode === 'viewer');
            document.body.classList.toggle('viewer-active', mode === 'viewer');
            document.body.classList.toggle('editor-active', mode === 'editor');
            
            if(mode === 'viewer') {
                deselectAll();
                await renderViewerMode();
            } else {
                ui.viewerContainer.innerHTML = ''; // Clear viewer to save memory
                // Re-load current editor page
                if(state.pdfDoc) loadPage(state.currentPage);
            }
        };

        ui.btnUpload.addEventListener('click', () => ui.fileInput.click());
        ui.fileInput.addEventListener('change', handleFileUpload);
        ui.btnExport.addEventListener('click', exportPDF);
        ui.btnUndo.addEventListener('click', undo);
        ui.btnRedo.addEventListener('click', redo);
        document.getElementById('btn-delete-element').addEventListener('click', deleteSelected);

        ui.propInputs.linkType.addEventListener('change', (e) => {
            if(e.target.value === 'url') {
                ui.groups.urlCont.style.display = 'block';
                ui.groups.pageCont.style.display = 'none';
            } else {
                ui.groups.urlCont.style.display = 'none';
                ui.groups.pageCont.style.display = 'block';
            }
        });

        ui.toolBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if(state.mode !== 'editor') return;
                ui.toolBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.tool = btn.dataset.tool;
                deselectAll();
                
                if(state.tool === 'cursor') {
                    ui.annotationLayer.classList.remove('tool-active');
                    ui.annotationLayer.dataset.tool = '';
                } else {
                    ui.annotationLayer.classList.add('tool-active');
                    ui.annotationLayer.dataset.tool = state.tool;
                }
            });
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) && 
                (e.key !== 'Delete' && e.key !== 'Backspace' && e.key !== 'Escape')) {
                return;
            }

            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                if (e.shiftKey) redo();
                else undo();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelected();
            } else if (e.key === 'Escape') {
                deselectAll();
            } else if (state.mode === 'editor' && !e.ctrlKey) {
                if(e.key.toLowerCase() === 'v') ui.toolBtns[0].click();
                if(e.key.toLowerCase() === 't') ui.toolBtns[1].click();
                if(e.key.toLowerCase() === 'r') ui.toolBtns[2].click();
                if(e.key.toLowerCase() === 'h') ui.toolBtns[3].click();
                if(e.key.toLowerCase() === 'l') ui.toolBtns[4].click();
            }
        });

        // --- History System ---
        function saveState() {
            const stateCopy = JSON.parse(JSON.stringify(state.elements));
            state.undoStack.push(stateCopy);
            if(state.undoStack.length > 20) state.undoStack.shift();
            state.redoStack = []; 
            updateHistoryButtons();
        }

        function undo() {
            if(state.undoStack.length === 0) return;
            state.redoStack.push(JSON.parse(JSON.stringify(state.elements)));
            state.elements = state.undoStack.pop();
            renderAnnotationsLayer();
            deselectAll();
            updateHistoryButtons();
            showToast("Undo");
        }

        function redo() {
            if(state.redoStack.length === 0) return;
            state.undoStack.push(JSON.parse(JSON.stringify(state.elements)));
            state.elements = state.redoStack.pop();
            renderAnnotationsLayer();
            deselectAll();
            updateHistoryButtons();
            showToast("Redo");
        }

        function updateHistoryButtons() {
            ui.btnUndo.disabled = state.undoStack.length === 0;
            ui.btnRedo.disabled = state.redoStack.length === 0;
        }

        // Input Listeners
        const bindProp = (elem, key, isNum = false) => {
            elem.addEventListener('change', () => { saveState(); });
            elem.addEventListener('input', () => {
                if(state.selectedIds.length === 0) return;
                const val = isNum ? parseFloat(elem.value) : elem.value;
                state.selectedIds.forEach(id => {
                    const elObj = state.elements[state.currentPage].find(e => e.id === id);
                    if(elObj) {
                        elObj[key] = val;
                        const dom = document.getElementById(`el-${id}`);
                        if(dom) {
                            renderElementStyles(elObj, dom);
                            if(key === 'text') {
                                dom.innerHTML = val;
                                if(val !== 'Type here...') {
                                    elObj.isPlaceholder = false;
                                    dom.style.color = hexToRgba(elObj.color, elObj.opacity);
                                }
                            }
                        }
                    }
                });
            });
        };
        ['x','y','w','h','opacity','borderWidth','fontSize'].forEach(k => bindProp(ui.propInputs[k], k, true));
        ['color','borderColor'].forEach(k => bindProp(ui.propInputs[k], k));
        
        ui.propInputs.text.addEventListener('input', (e) => {
            if(state.selectedIds.length !== 1) return;
            const id = state.selectedIds[0];
            const el = state.elements[state.currentPage].find(x => x.id === id);
            el.text = e.target.value;
            const dom = document.getElementById(`el-${id}`);
            dom.innerHTML = e.target.value;
            if(e.target.value !== 'Type here...') {
                el.isPlaceholder = false;
                dom.style.color = hexToRgba(el.color, el.opacity);
            }
        });
        ui.propInputs.text.addEventListener('change', () => saveState());

        ui.propInputs.linkUrl.addEventListener('change', (e) => { updateLinkData('url', e.target.value); saveState(); });
        ui.propInputs.linkPage.addEventListener('change', (e) => { updateLinkData('targetPage', parseInt(e.target.value)); saveState(); });

        function updateLinkData(key, val) {
            if(state.selectedIds.length !== 1) return;
            const id = state.selectedIds[0];
            const el = state.elements[state.currentPage].find(x => x.id === id);
            if(el && el.type === 'link') {
                el[key] = val;
                if(key === 'targetPage') { el.url = null; el.hasContent = true; }
                else if (key === 'url') { el.targetPage = null; el.hasContent = true; }
                const dom = document.getElementById(`el-${id}`);
                if(dom) renderElementStyles(el, dom);
            }
        }

        // --- Core Logic ---

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if(!file) return;
            showLoader('Loading...');
            const arrayBuffer = await file.arrayBuffer();
            state.rawPdfBytes = arrayBuffer;
            try {
                const loadingTask = pdfjsLib.getDocument(arrayBuffer);
                state.pdfDoc = await loadingTask.promise;
                state.elements = {};
                state.currentPage = 1;
                state.undoStack = [];
                state.redoStack = [];
                updateHistoryButtons();
                
                renderThumbnails();
                loadPage(1);
                showToast('PDF Loaded');
            } catch (err) {
                console.error(err);
                showToast('Error loading PDF');
            } finally { hideLoader(); }
        }

        function renderThumbnails() {
            ui.sidebar.innerHTML = '';
            const numPages = state.pdfDoc.numPages;
            for(let i=1; i<=numPages; i++) {
                const thumbWrap = document.createElement('div');
                thumbWrap.className = `page-thumbnail ${i===state.currentPage ? 'active' : ''}`;
                thumbWrap.dataset.pageNum = i; // Store page number
                thumbWrap.onclick = () => loadPageOrScroll(i);
                
                const canvas = document.createElement('canvas');
                state.pdfDoc.getPage(i).then(page => {
                    const vp = page.getViewport({ scale: 0.2 });
                    canvas.height = vp.height; canvas.width = vp.width;
                    page.render({ canvasContext: canvas.getContext('2d'), viewport: vp });
                });
                const num = document.createElement('div');
                num.className = 'page-number'; num.innerText = `Page ${i}`;
                thumbWrap.appendChild(canvas); thumbWrap.appendChild(num);
                ui.sidebar.appendChild(thumbWrap);
            }
        }

        async function loadPageOrScroll(pn) {
            if(state.mode === 'viewer') {
                const target = document.getElementById(`viewer-page-${pn}`);
                if(target) target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
                loadPage(pn);
            }
        }

        async function loadPage(pn) {
            if(!state.pdfDoc) return;
            state.currentPage = pn;
            ui.pageIndicator.innerText = `Page ${pn} of ${state.pdfDoc.numPages}`;
            document.querySelectorAll('.page-thumbnail').forEach(t => {
                t.classList.toggle('active', parseInt(t.dataset.pageNum) === pn);
            });

            const page = await state.pdfDoc.getPage(pn);
            const vp = page.getViewport({ scale: state.scale });
            ui.canvas.height = vp.height; ui.canvas.width = vp.width;
            ui.editorContainer.style.width = `${vp.width}px`; ui.editorContainer.style.height = `${vp.height}px`;
            await page.render({ canvasContext: ui.canvas.getContext('2d'), viewport: vp }).promise;
            
            if(!state.elements[pn]) state.elements[pn] = [];
            renderAnnotationsLayer();
        }

        // --- Viewer Mode Generation ---
        async function renderViewerMode() {
            if(!state.pdfDoc) return;
            ui.viewerContainer.innerHTML = ''; 
            const numPages = state.pdfDoc.numPages;

            for(let i=1; i<=numPages; i++) {
                const page = await state.pdfDoc.getPage(i);
                const vp = page.getViewport({ scale: state.scale });
                
                const wrap = document.createElement('div');
                wrap.className = 'viewer-page-wrap';
                wrap.style.width = `${vp.width}px`;
                wrap.style.height = `${vp.height}px`;
                wrap.id = `viewer-page-${i}`;
                wrap.dataset.pageNum = i; 
                
                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-canvas';
                canvas.height = vp.height; canvas.width = vp.width;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
                
                const layer = document.createElement('div');
                layer.className = 'pdf-element';
                layer.style.position = 'absolute';
                layer.style.top = '0'; layer.style.left = '0';
                layer.style.width = '100%'; layer.style.height = '100%';
                layer.style.pointerEvents = 'none'; 

                const pageEls = state.elements[i] || [];
                pageEls.forEach(el => {
                    if(el.type === 'link') {
                        const linkBox = document.createElement('div');
                        linkBox.className = 'el-link pdf-element';
                        renderElementStyles(el, linkBox);
                        linkBox.style.pointerEvents = 'auto';
                        
                        linkBox.addEventListener('click', (e) => {
                            e.preventDefault();
                            if(el.url) {
                                window.open(el.url, '_blank');
                            } else if(el.targetPage) {
                                const target = document.getElementById(`viewer-page-${el.targetPage}`);
                                if(target) target.scrollIntoView({ behavior: 'smooth' });
                            }
                        });
                        
                        layer.appendChild(linkBox);
                    }
                });

                wrap.appendChild(canvas);
                wrap.appendChild(layer);
                ui.viewerContainer.appendChild(wrap);
            }
            
            updateViewerPageIndicator();
        }

        ui.viewerContainer.addEventListener('scroll', () => {
            updateViewerPageIndicator();
        });

        function updateViewerPageIndicator() {
            if(state.mode !== 'viewer') return;
            const containerRect = ui.viewerContainer.getBoundingClientRect();
            const scrollMiddle = ui.viewerContainer.scrollTop + (containerRect.height / 2);
            
            let closestPage = 1;
            let minDist = Infinity;

            const pages = ui.viewerContainer.querySelectorAll('.viewer-page-wrap');
            pages.forEach(page => {
                const pageTop = page.offsetTop;
                const dist = Math.abs(scrollMiddle - pageTop);
                if(dist < minDist) {
                    minDist = dist;
                    closestPage = parseInt(page.dataset.pageNum);
                }
            });

            if(closestPage !== state.currentPage) {
                state.currentPage = closestPage;
                ui.pageIndicator.innerText = `Page ${state.currentPage} of ${state.pdfDoc.numPages}`;
                document.querySelectorAll('.page-thumbnail').forEach(t => {
                    t.classList.toggle('active', parseInt(t.dataset.pageNum) === state.currentPage);
                });
            }
        }

        function renderAnnotationsLayer() {
            ui.annotationLayer.innerHTML = '';
            const els = state.elements[state.currentPage] || [];
            
            els.forEach(el => {
                const dom = document.createElement('div');
                dom.className = 'pdf-element';
                dom.id = `el-${el.id}`;
                if(el.type==='text') dom.classList.add('el-text');
                else if(el.type==='link') dom.classList.add('el-link');
                else dom.classList.add('el-rect');

                renderElementStyles(el, dom);

                if(el.type==='text') {
                    dom.contentEditable = (state.mode === 'editor'); 
                    if(dom.contentEditable) {
                        dom.innerHTML = el.text; 
                        
                        const placeholderText = 'Type here...';
                        const setPlaceholder = () => {
                            dom.innerText = placeholderText;
                            dom.style.color = '#888'; 
                            el.isPlaceholder = true;
                        };

                        if(el.text === '' || el.isPlaceholder === true) {
                            setPlaceholder();
                        }

                        dom.addEventListener('focus', () => {
                            if(dom.innerText === placeholderText) {
                                dom.innerText = '';
                                dom.style.color = hexToRgba(el.color, el.opacity); 
                                el.isPlaceholder = false;
                            }
                        });

                        dom.addEventListener('blur', () => {
                            el.text = dom.innerHTML;
                            if(dom.innerText === '') {
                                setPlaceholder();
                            }
                            if(el.text !== placeholderText) saveState();
                        });
                        
                        dom.addEventListener('input', () => { el.text = dom.innerHTML; });
                    } else {
                        if(el.isPlaceholder) dom.innerHTML = '';
                        else dom.innerHTML = el.text;
                    }
                }

                if(state.mode === 'editor') {
                    ['nw','ne','sw','se'].forEach(dir => {
                        const h = document.createElement('div');
                        h.className = `resize-handle rh-${dir}`;
                        h.dataset.dir = dir;
                        h.addEventListener('mousedown', (e) => startResize(e, el.id, dir));
                        dom.appendChild(h);
                    });
                }

                if(state.mode === 'editor') {
                    dom.addEventListener('mousedown', (e) => {
                        if(state.tool === 'cursor') {
                            if(!state.selectedIds.includes(el.id)) {
                                if(!e.shiftKey) deselectAll();
                                addToSelection(el.id);
                            }
                            startDrag(e);
                            e.stopPropagation();
                        }
                    });
                }

                ui.annotationLayer.appendChild(dom);
            });
            updateSelectionVisuals();
        }

        function renderElementStyles(el, dom) {
            dom.style.left = `${el.x}px`; dom.style.top = `${el.y}px`;
            dom.style.width = `${el.w}px`; dom.style.height = `${el.h}px`;
            
            if(el.type === 'highlight') {
                dom.style.backgroundColor = hexToRgba(el.color, el.opacity);
                dom.style.mixBlendMode = 'multiply';
            } else if (el.type === 'rect') {
                dom.style.backgroundColor = hexToRgba(el.color, el.opacity);
                dom.style.border = `${el.borderWidth}px solid ${el.borderColor}`;
                dom.style.borderRadius = '4px';
            } else if (el.type === 'text') {
                if(!el.isPlaceholder) {
                    dom.style.color = hexToRgba(el.color, el.opacity); 
                } else {
                    dom.style.color = '#888';
                }
            } else if (el.type === 'link') {
                dom.style.backgroundColor = hexToRgba(el.color, el.opacity);
                dom.style.border = `${el.borderWidth}px solid ${el.borderColor}`;
                
                const isInvisible = el.borderWidth === 0 && el.opacity === 0;
                if(isInvisible) dom.classList.add('ghost-border');
                else dom.classList.remove('ghost-border');
                
                if(el.url || el.targetPage) dom.classList.add('has-content');
                else dom.classList.remove('has-content');
            }
        }

        // --- INTERACTION LOGIC (REWRITTEN FROM SCRATCH) ---

        // Listen on Editor Container
        ui.editorContainer.addEventListener('mousedown', (e) => {
            if(state.mode !== 'editor') return;

            // CHECK 1: Are we clicking an element?
            const clickedElement = e.target.closest('.pdf-element');

            if(clickedElement) {
                // --- ELEMENT CLICKED ---
                if(state.tool === 'cursor') {
                    const id = clickedElement.id.replace('el-', '');
                    if(!state.selectedIds.includes(id)) {
                        if(!e.shiftKey) deselectAll();
                        addToSelection(id);
                    }
                    startDrag(e);
                }
            } else {
                // --- BACKGROUND CLICKED ---
                if(state.tool !== 'cursor') {
                    // CREATION TOOLS (Draw on background)
                    createNewElement(e);
                } else {
                    // MARQUEE (Select on background)
                    deselectAll();
                    startMarquee(e);
                }
            }
        });

        // --- MARQUEE FUNCTIONS ---
        function startMarquee(e) {
            state.isMarquee = true;
            const rect = ui.editorContainer.getBoundingClientRect();
            state.dragStart = { 
                x: e.clientX - rect.left, 
                y: e.clientY - rect.top 
            };
            
            ui.marqueeBox.style.display = 'block';
            ui.marqueeBox.style.left = `${state.dragStart.x}px`;
            ui.marqueeBox.style.top = `${state.dragStart.y}px`;
            ui.marqueeBox.style.width = '0px';
            ui.marqueeBox.style.height = '0px';
        }

        function updateMarquee(e) {
            if(!state.isMarquee) return;
            
            const rect = ui.editorContainer.getBoundingClientRect();
            const currX = e.clientX - rect.left;
            const currY = e.clientY - rect.top;

            // Calculate Geometry (Handle dragging Up/Left/Down/Right)
            const width = Math.abs(currX - state.dragStart.x);
            const height = Math.abs(currY - state.dragStart.y);
            const left = Math.min(currX, state.dragStart.x);
            const top = Math.min(currY, state.dragStart.y);

            // Update Visual Box
            ui.marqueeBox.style.width = `${width}px`;
            ui.marqueeBox.style.height = `${height}px`;
            ui.marqueeBox.style.left = `${left}px`;
            ui.marqueeBox.style.top = `${top}px`;

            // Live Highlight Logic
            const els = state.elements[state.currentPage] || [];
            els.forEach(el => {
                const dom = document.getElementById(`el-${el.id}`);
                // AABB Collision
                const intersect = !(el.x > left + width || (el.x + el.w) < left || el.y > top + height || (el.y + el.h) < top);
                if(intersect) dom.classList.add('marquee-highlight');
                else dom.classList.remove('marquee-highlight');
            });
        }

        function finishMarquee() {
            state.isMarquee = false;
            ui.marqueeBox.style.display = 'none';

            // Select Highlights
            const els = state.elements[state.currentPage] || [];
            els.forEach(el => {
                const dom = document.getElementById(`el-${el.id}`);
                if(dom.classList.contains('marquee-highlight')) {
                    addToSelection(el.id);
                    dom.classList.remove('marquee-highlight');
                }
            });
            if(state.selectedIds.length > 0) ui.propertiesPanel.classList.remove('visible');
        }
        // --- END MARQUEE FUNCTIONS ---

        // --- DRAG & RESIZE ---

        function createNewElement(e) {
            const rect = ui.annotationLayer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const id = Date.now().toString();

            let newEl = {
                id, x, y, w:100, h:50, color:'#000000', opacity:0.5, borderWidth:2, borderColor:'#ff0000', fontSize:16
            };

            if(state.tool === 'text') {
                newEl.type='text'; 
                newEl.text='Type here...'; 
                newEl.isPlaceholder = true;
                newEl.w=150; newEl.h=40; 
                newEl.color='#000000'; 
                newEl.opacity=1; newEl.borderWidth=0;
            } else if (state.tool === 'rect') {
                newEl.type='rect';
            } else if (state.tool === 'highlight') {
                newEl.type='highlight'; newEl.w=200; newEl.h=30; newEl.color='#ffff00'; newEl.borderWidth=0;
            } else if (state.tool === 'link') {
                newEl.type='link'; 
                newEl.color='#000000'; 
                newEl.opacity = 0;      
                newEl.borderWidth = 1;  
                newEl.borderColor = '#000000';
                newEl.url='https://';
            }

            if(!state.elements[state.currentPage]) state.elements[state.currentPage] = [];
            state.elements[state.currentPage].push(newEl);
            saveState(); 
            renderAnnotationsLayer();
            addToSelection(id);
            startDrag(e);
        }

        window.addEventListener('mousemove', (e) => {
            if(state.mode !== 'editor') return;
            if(state.isDragging) handleDrag(e);
            if(state.isResizing) handleResize(e);
            if(state.isMarquee) updateMarquee(e);
        });

        window.addEventListener('mouseup', () => {
            if(state.mode !== 'editor') return;
            if(state.isDragging) {
                state.isDragging = false;
                saveState(); 
                updatePropPanel();
            }
            if(state.isResizing) {
                state.isResizing = false;
                saveState(); 
                updatePropPanel();
            }
            if(state.isMarquee) finishMarquee();
        });

        function handleDrag(e) {
            const dx = e.clientX - state.dragStart.x;
            const dy = e.clientY - state.dragStart.y;

            state.selectedIds.forEach(id => {
                const el = state.elements[state.currentPage].find(x => x.id === id);
                const dom = document.getElementById(`el-${id}`);
                if(el && dom) {
                    el.x = state.initialEls[id].x + dx;
                    el.y = state.initialEls[id].y + dy;
                    dom.style.left = `${el.x}px`;
                    dom.style.top = `${el.y}px`;
                }
            });
        }

        function startDrag(e) {
            if(state.isResizing || state.isMarquee) return;
            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            state.initialEls = {};
            state.selectedIds.forEach(id => {
                const el = state.elements[state.currentPage].find(x => x.id === id);
                state.initialEls[id] = { x: el.x, y: el.y, w: el.w, h: el.h };
            });
        }

        function startResize(e, id, dir) {
            e.stopPropagation();
            e.preventDefault();
            state.isResizing = true;
            state.resizeDir = dir;
            state.dragStart = { x: e.clientX, y: e.clientY };
            
            state.selectedIds = [id];
            updateSelectionVisuals();
            updatePropPanel();

            const el = state.elements[state.currentPage].find(x => x.id === id);
            state.initialEls[id] = { x: el.x, y: el.y, w: el.w, h: el.h };
        }

        function handleResize(e) {
            const dx = e.clientX - state.dragStart.x;
            const dy = e.clientY - state.dragStart.y;
            const id = state.selectedIds[0];
            const el = state.elements[state.currentPage].find(x => x.id === id);
            const init = state.initialEls[id];
            const dom = document.getElementById(`el-${id}`);

            let nx = init.x, ny = init.y, nw = init.w, nh = init.h;

            if(state.resizeDir.includes('e')) nw = Math.max(10, init.w + dx);
            if(state.resizeDir.includes('s')) nh = Math.max(10, init.h + dy);
            if(state.resizeDir.includes('w')) {
                const newW = Math.max(10, init.w - dx);
                nx = init.x + (init.w - newW);
                nw = newW;
            }
            if(state.resizeDir.includes('n')) {
                const newH = Math.max(10, init.h - dy);
                ny = init.y + (init.h - newH);
                nh = newH;
            }

            el.x = nx; el.y = ny; el.w = nw; el.h = nh;
            dom.style.left = `${nx}px`; dom.style.top = `${ny}px`;
            dom.style.width = `${nw}px`; dom.style.height = `${nh}px`;
        }

        // --- Selection ---

        function addToSelection(id) {
            if(!state.selectedIds.includes(id)) state.selectedIds.push(id);
            updateSelectionVisuals();
            updatePropPanel();
        }

        function deselectAll() {
            state.selectedIds = [];
            updateSelectionVisuals();
            ui.propertiesPanel.classList.remove('visible');
        }

        function updateSelectionVisuals() {
            document.querySelectorAll('.pdf-element').forEach(dom => {
                dom.classList.remove('selected');
                dom.classList.remove('group-selected');
            });

            state.selectedIds.forEach(id => {
                const dom = document.getElementById(`el-${id}`);
                if(dom) dom.classList.add('selected');
            });

            if(state.selectedIds.length > 1) {
                state.selectedIds.forEach(id => {
                    const dom = document.getElementById(`el-${id}`);
                    if(dom) dom.classList.add('group-selected');
                });
            }
        }

        function updatePropPanel() {
            if(state.selectedIds.length === 0) {
                ui.propertiesPanel.classList.remove('visible');
                return;
            }
            ui.propertiesPanel.classList.add('visible');

            if(state.selectedIds.length > 1) {
                ui.multiMsg.style.display = 'block';
                ui.groups.pos.style.display = 'none';
                ui.groups.dim.style.display = 'none';
                ui.groups.color.style.display = 'none';
                ui.groups.border.style.display = 'none';
                ui.groups.text.style.display = 'none';
                ui.groups.link.style.display = 'none';
                return;
            }

            ui.multiMsg.style.display = 'none';
            ui.groups.pos.style.display = 'block';
            ui.groups.dim.style.display = 'block';
            ui.groups.color.style.display = 'block';
            ui.groups.border.style.display = 'block';

            const id = state.selectedIds[0];
            const el = state.elements[state.currentPage].find(e => e.id === id);
            if(!el) return;

            ui.propInputs.x.value = Math.round(el.x);
            ui.propInputs.y.value = Math.round(el.y);
            ui.propInputs.w.value = Math.round(el.w);
            ui.propInputs.h.value = Math.round(el.h);
            ui.propInputs.color.value = el.color;
            ui.propInputs.opacity.value = el.opacity;
            ui.propInputs.borderWidth.value = el.borderWidth;
            ui.propInputs.borderColor.value = el.borderColor;

            ui.groups.text.style.display = 'none';
            ui.groups.link.style.display = 'none';

            if(el.type === 'text') {
                ui.groups.text.style.display = 'block';
                ui.groups.border.style.display = 'none';
                ui.propInputs.text.value = el.text;
                ui.propInputs.fontSize.value = el.fontSize;
            } else if (el.type === 'link') {
                ui.groups.link.style.display = 'block';
                ui.propInputs.linkUrl.value = el.url || '';
                ui.propInputs.linkPage.value = el.targetPage || '';
                
                if(el.targetPage) {
                    ui.propInputs.linkType.value = 'page';
                    ui.groups.urlCont.style.display = 'none';
                    ui.groups.pageCont.style.display = 'block';
                } else {
                    ui.propInputs.linkType.value = 'url';
                    ui.groups.urlCont.style.display = 'block';
                    ui.groups.pageCont.style.display = 'none';
                }
            } else if (el.type === 'highlight') {
                ui.groups.border.style.display = 'none';
            }
        }

        function deleteSelected() {
            if(state.mode !== 'editor') return;
            if(state.selectedIds.length === 0) return;
            if(document.activeElement.isContentEditable) return;

            saveState();
            const arr = state.elements[state.currentPage];
            state.selectedIds.forEach(id => {
                const idx = arr.findIndex(e => e.id === id);
                if(idx > -1) arr.splice(idx, 1);
            });
            renderAnnotationsLayer();
            deselectAll();
        }

        // --- Export ---

        async function exportPDF() {
            if(!state.rawPdfBytes) return;
            showLoader('Generating PDF...');
            try {
                const { PDFDocument, rgb } = PDFLib;
                const pdfDoc = await PDFDocument.load(state.rawPdfBytes);
                const pages = pdfDoc.getPages();
                const helveticaFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);

                for (let [pn, annotations] of Object.entries(state.elements)) {
                    const pageNum = parseInt(pn);
                    const page = pages[pageNum - 1];
                    if (!page) continue;

                    const { width, height } = page.getSize();
                    const pdfPage = await state.pdfDoc.getPage(pageNum);
                    const vp = pdfPage.getViewport({ scale: state.scale });
                    const scaleRatio = width / vp.width;

                    for (const el of annotations) {
                        const x = el.x * scaleRatio;
                        const pdfY = height - (el.y * scaleRatio) - (el.h * scaleRatio);
                        const w = el.w * scaleRatio;
                        const h = el.h * scaleRatio;

                        if (el.type === 'highlight') {
                            page.drawRectangle({ x, y: pdfY, width: w, height: h, color: hexToRgbFloat(el.color), opacity: el.opacity });
                        } else if (el.type === 'rect') {
                            page.drawRectangle({ 
                                x, y: pdfY, width: w, height: h,
                                color: hexToRgbFloat(el.color),
                                borderColor: hexToRgbFloat(el.borderColor),
                                borderWidth: el.borderWidth * scaleRatio,
                                opacity: el.opacity
                            });
                        } else if (el.type === 'text') {
                            const plainText = el.text.replace(/<[^>]*>?/gm, '');
                            if(plainText.trim() === '') continue;
                            
                            const lines = plainText.split(/\r\n|\r|\n/);
                            const fontSize = el.fontSize * scaleRatio;
                            const lineHeight = fontSize * 1.2;
                            lines.forEach((line, i) => {
                                page.drawText(line, {
                                    x: x, y: pdfY + h - fontSize - (i * lineHeight),
                                    size: fontSize, font: helveticaFont, color: hexToRgbFloat(el.color)
                                });
                            });
                        } else if (el.type === 'link') {
                            if(el.borderWidth > 0 || el.opacity > 0) {
                                page.drawRectangle({
                                    x, y: pdfY, width: w, height: h,
                                    color: hexToRgbFloat(el.color),
                                    borderColor: hexToRgbFloat(el.borderColor),
                                    borderWidth: el.borderWidth * scaleRatio,
                                    opacity: el.opacity,
                                });
                            }

                            let actionObj;
                            if (el.targetPage) {
                                const destPageIdx = el.targetPage - 1;
                                if(destPageIdx >= 0 && destPageIdx < pages.length) {
                                    const destPageRef = pages[destPageIdx].ref;
                                    actionObj = { Type: 'Action', S: 'GoTo', D: [destPageRef, 'XYZ', null, null, null] };
                                }
                            } else if (el.url) {
                                actionObj = { Type: 'Action', S: 'URI', URI: PDFLib.String.of(el.url) };
                            }

                            if(actionObj) {
                                const linkAnnot = pdfDoc.context.register(
                                    pdfDoc.doc.context.obj({
                                        Type: 'Annot', Subtype: 'Link',
                                        Rect: [x, pdfY, x + w, pdfY + h],
                                        Border: [0, 0, 0],
                                        C: [0, 0, 0],
                                        A: actionObj
                                    })
                                );
                                pdfDoc.context.get(page.ref).getArray('Annots').push(linkAnnot);
                            }
                        }
                    }
                }

                const pdfBytes = await pdfDoc.save();
                download(pdfBytes, "edited-document.pdf", "application/pdf");
                showToast("PDF Exported Successfully");
            } catch (err) {
                console.error(err);
                showToast("Export Error: See Console");
            } finally {
                hideLoader();
            }
        }

        // --- Helpers ---
        function hexToRgbFloat(hex) {
            return {
                r: parseInt(hex.slice(1, 3), 16) / 255,
                g: parseInt(hex.slice(3, 5), 16) / 255,
                b: parseInt(hex.slice(5, 7), 16) / 255
            };
        }
        function hexToRgba(hex, a) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${a})`;
        }
        function download(data, name, type) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([data], {type}));
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        function showLoader(t) { ui.loader.classList.remove('hidden'); document.getElementById('loader-text').innerText=t; }
        function hideLoader() { ui.loader.classList.add('hidden'); }
        function showToast(m) { ui.toast.innerText=m; ui.toast.classList.add('show'); setTimeout(()=>ui.toast.classList.remove('show'),3000); }

    </script>
</body>
</html>