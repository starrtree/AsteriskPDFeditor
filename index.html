<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Web PDF Editor (With Auto-Scroll)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-header: #333333;
            --accent: #007acc;
            --border: #3e3e42;
            --text: #cccccc;
            --text-muted: #858585;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* --- Header --- */
        header {
            height: 50px;
            background: var(--bg-header);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
            justify-content: space-between;
            z-index: 100;
        }
        .brand { font-weight: bold; color: white; display: flex; align-items: center; gap: 10px; }
        
        .toolbar { display: flex; gap: 5px; align-items: center; }
        button {
            background: none;
            border: none;
            color: var(--text);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex; align-items: center; gap: 6px;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        button.active { background: var(--accent); color: white; }

        .separator { width: 1px; height: 20px; background: var(--border); margin: 0 10px; }

        /* Zoom Slider */
        .zoom-control { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        input[type=range].zoom-slider { width: 80px; cursor: pointer; }

        /* --- Main Layout --- */
        main { display: flex; flex: 1; overflow: hidden; }

        /* --- Sidebar --- */
        .sidebar {
            width: 200px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            overflow-y: auto; /* Scrollable */
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* Invisible overlay for scroll zones visual feedback (optional) */
        .sidebar::before, .sidebar::after {
            content: "";
            position: absolute;
            left: 0; right: 0;
            height: 50px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 50;
        }
        .sidebar::before { top: 0; background: linear-gradient(to bottom, rgba(0,122,204,0.2), transparent); }
        .sidebar::after { bottom: 0; background: linear-gradient(to top, rgba(0,122,204,0.2), transparent); }
        
        .sidebar.scroll-top::before { opacity: 1; }
        .sidebar.scroll-bottom::after { opacity: 1; }

        .thumb { 
            margin: 10px; 
            cursor: grab; 
            opacity: 0.6; 
            text-align: center; 
            border: 2px solid transparent;
            transition: transform 0.2s, opacity 0.2s;
            background: var(--bg-dark);
            padding: 5px;
            border-radius: 4px;
            position: relative;
        }
        .thumb:hover { opacity: 1; }
        .thumb.active { opacity: 1; border-color: var(--accent); }
        
        /* Dragging States */
        .thumb.dragging { opacity: 0.5; transform: scale(0.95); cursor: grabbing; }
        .thumb.drag-over { border-color: var(--accent); opacity: 0.8; border-style: dashed; background: #333; }

        .thumb canvas { max-width: 100%; box-shadow: 0 2px 5px rgba(0,0,0,0.5); pointer-events: none; }
        .thumb-page-num { font-size: 10px; text-align: center; margin-top: 4px; color: var(--text-muted); pointer-events: none; }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            background: #525659;
            overflow-y: auto;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            position: relative;
        }

        .page {
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: width 0.2s, height 0.2s; /* Smooth zoom */
        }

        /* --- Annotations --- */
        .annotation {
            position: absolute;
            cursor: move;
            box-sizing: border-box;
            user-select: none;
            border-style: solid; 
        }
        
        .type-rect {  }
        .type-link { cursor: pointer; }
        
        .type-text, .type-link {
            color: black;
            font-size: 16px;
            padding: 4px;
            font-family: Helvetica, Arial, sans-serif;
            border-style: solid; 
            display: flex;
            align-items: center;
        }
        
        .type-link .text-content { color: blue; text-decoration: underline; }
        
        .type-text:hover, .type-rect:hover, .type-link:hover { border-style: dashed !important; border-color: #888 !important; }
        
        .text-content { 
            width: 100%; height: 100%; 
            outline: none; cursor: text;
            white-space: pre;
            overflow: hidden;
        }
        .placeholder { color: #aaa; font-style: italic; pointer-events: none; }

        /* Selection & Handles */
        .selected { outline: 2px solid #ff9900 !important; z-index: 100; }
        
        .selected .resize-handle, 
        .type-text:hover .resize-handle, 
        .type-rect:hover .resize-handle,
        .type-link:hover .resize-handle {
            display: block;
        }

        .resize-handle {
            position: absolute;
            width: 10px; height: 10px;
            background: white; border: 1px solid #ff9900;
            display: none; 
            z-index: 101;
        }

        /* --- Marquee Box --- */
        #marquee-box {
            position: fixed; 
            display: none;
            background-color: rgba(0, 122, 204, 0.1);
            border: 1px dashed #00d4ff; 
            z-index: 2000;
            pointer-events: none; 
        }

        /* --- Properties Panel --- */
        .properties {
            width: 280px; 
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .prop-row { display: flex; gap: 10px; align-items: center; } 
        .prop-row.inputs-bottom { align-items: flex-end; } 
        
        .prop-group { flex: 1; display: flex; flex-direction: column; gap: 4px; }
        .prop-group label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }
        
        input[type="number"], textarea, select {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px;
            border-radius: 3px;
            font-family: inherit;
            width: 100%;
            box-sizing: border-box;
        }
        input[type="number"]:focus, textarea:focus, select:focus { border-color: var(--accent); outline: none; }
        textarea { resize: vertical; min-height: 60px; }

        input[type="range"] { width: 100%; cursor: pointer; }

        /* Color Picker Styling */
        input[type="color"] {
            -webkit-appearance: none;
            border: 1px solid var(--border);
            width: 100%;
            height: 30px;
            background: none;
            padding: 0;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }

        .empty-state { color: var(--text-muted); text-align: center; margin-top: 50px; font-style: italic; }
        
        #loader {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 9999;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 20px;
        }

        /* Modal */
        #modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000;
            display: none; align-items: center; justify-content: center;
        }
        .modal {
            background: var(--bg-panel); padding: 20px; border-radius: 5px; width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .modal h3 { margin-top: 0; color: white; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <header>
        <div class="brand">
            <i class="fas fa-file-pdf"></i> PDF Editor Pro
        </div>
        <div class="toolbar">
            <button onclick="document.getElementById('file-in').click()">Open PDF</button>
            <input type="file" id="file-in" class="hidden" accept=".pdf">
            
            <button onclick="document.getElementById('file-insert').click()">Insert PDF</button>
            <input type="file" id="file-insert" class="hidden" accept=".pdf">
            
            <div class="separator"></div>
            
            <button id="btn-cursor" class="active" onclick="setTool('cursor')" title="Select"><i class="fas fa-mouse-pointer"></i></button>
            <button id="btn-rect" onclick="setTool('rect')" title="Rectangle"><i class="far fa-square"></i></button>
            <button id="btn-text" onclick="setTool('text')" title="Text"><i class="fas fa-font"></i></button>
            <button id="btn-link" onclick="setTool('link')" title="Hyperlink"><i class="fas fa-link"></i></button>
            
            <div class="separator"></div>
            
            <button onclick="undo()" title="Undo"><i class="fas fa-undo"></i></button>
            <button onclick="redo()" title="Redo"><i class="fas fa-redo"></i></button>
            
            <div class="separator"></div>
            
            <button onclick="app.exportData()">Save JSON</button>
        </div>
        <div style="display:flex; align-items:center; gap:15px;">
            <div class="zoom-control">
                <i class="fas fa-search-minus" onclick="adjustZoom(-0.1)" style="cursor:pointer"></i>
                <input type="range" min="0.5" max="3.0" step="0.1" value="1.0" class="zoom-slider" id="zoom-slider">
                <i class="fas fa-search-plus" onclick="adjustZoom(0.1)" style="cursor:pointer"></i>
                <span id="zoom-label" style="width: 35px">100%</span>
            </div>
            <div style="color: var(--text-muted); font-size: 12px; min-width: 60px; text-align:right;">
                <span id="page-num">Page 1</span>
            </div>
        </div>
    </header>

    <main>
        <div class="sidebar" id="sidebar">
            <div style="padding: 10px; color: var(--text-muted); font-size: 11px; text-align: center;">
                Drag pages to reorder
            </div>
            <div id="thumb-container" style="display: flex; flex-direction: column; gap: 10px; padding: 10px;"></div>
        </div>
        
        <div class="workspace" id="workspace">
            <div id="loader" class="hidden">Loading PDF...</div>
            <div id="marquee-box"></div>
        </div>
        
        <div class="properties" id="prop-panel">
            <div class="empty-state">No Element Selected</div>
        </div>
    </main>

    <!-- Insert PDF Modal -->
    <div id="modal-overlay">
        <div class="modal">
            <h3>Insert PDF</h3>
            <div class="prop-group">
                <label>Insert After Page #</label>
                <input type="number" id="insert-page-num" value="1" min="1">
            </div>
            <div class="empty-state" style="margin-top: 10px; margin-bottom: 10px;">Pages will be inserted at the selected position.</div>
            <div class="modal-actions">
                <button onclick="closeModal()">Cancel</button>
                <button style="background: var(--accent); color: white;" onclick="confirmInsert()">Insert</button>
            </div>
        </div>
    </div>

    <script>
        // --- Registry for PDF Documents (Required for robust Undo/Redo) ---
        const docRegistry = {}; 

        // --- State Management ---
        const state = {
            pages: [], // Array of { pdfDocRef (string), pageIndex (int), id (unique string) }
            totalVisualPages: 0,
            scale: 1.0, // Default zoom
            tool: 'cursor', 
            elements: [], // Flat array of elements
            history: [],
            historyIndex: -1,
            selections: [], 
            
            isDragging: false,
            isResizing: false,
            isDrawing: false,
            isMarquee: false, 
            resizeHandle: null,
            
            startPos: { x: 0, y: 0 },
            initialEls: [], 
            marqueeStart: { x: 0, y: 0 },
            
            tempInsertPdf: null,
            tempInsertPageCount: 0,
            
            draggedPageVisualIndex: null
        };

        // --- DOM Cache ---
        const ui = {
            workspace: document.getElementById('workspace'),
            sidebar: document.getElementById('sidebar'),
            thumbContainer: document.getElementById('thumb-container'),
            props: document.getElementById('prop-panel'),
            pageLabel: document.getElementById('page-num'),
            loader: document.getElementById('loader'),
            marquee: document.getElementById('marquee-box'),
            modal: document.getElementById('modal-overlay'),
            insertInput: document.getElementById('insert-page-num'),
            zoomSlider: document.getElementById('zoom-slider'),
            zoomLabel: document.getElementById('zoom-label'),
            btns: {
                cursor: document.getElementById('btn-cursor'),
                rect: document.getElementById('btn-rect'),
                text: document.getElementById('btn-text'),
                link: document.getElementById('btn-link')
            }
        };

        // --- Initialization ---
        document.getElementById('file-in').addEventListener('change', (e) => loadPDF(e.target.files[0], true));
        document.getElementById('file-insert').addEventListener('change', (e) => prepareInsert(e.target.files[0]));
        
        // Zoom Listener
        ui.zoomSlider.addEventListener('input', (e) => {
            state.scale = parseFloat(e.target.value);
            ui.zoomLabel.innerText = Math.round(state.scale * 100) + '%';
            debouncedRender();
        });

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        ui.workspace.addEventListener('scroll', checkPageVisible); // Update page num on scroll
        
        // --- Auto Scroll Logic for Sidebar ---
        // Listen on the container, not just the thumbs, to detect dragging in empty space
        ui.thumbContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow dropping
            
            const container = ui.thumbContainer;
            const rect = container.getBoundingClientRect();
            const mouseY = e.clientY - rect.top;
            
            // Threshold and Speed config
            const threshold = 50; 
            const speed = 15;
            
            // Check Top Zone
            if (mouseY < threshold && container.scrollTop > 0) {
                container.scrollTop -= speed;
                ui.sidebar.classList.add('scroll-top');
            } else {
                ui.sidebar.classList.remove('scroll-top');
            }
            
            // Check Bottom Zone
            if (mouseY > rect.height - threshold) {
                container.scrollTop += speed;
                ui.sidebar.classList.add('scroll-bottom');
            } else {
                ui.sidebar.classList.remove('scroll-bottom');
            }
        });

        // Cleanup scroll indicators on drag end
        window.addEventListener('dragend', () => {
            ui.sidebar.classList.remove('scroll-top', 'scroll-bottom');
        });

        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') undo();
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') redo();
            if (e.key === 'Delete' && state.selections.length > 0 && !document.activeElement.isContentEditable) deleteSelections();
        });

        function setTool(tool) {
            state.tool = tool;
            Object.values(ui.btns).forEach(b => b.classList.remove('active'));
            ui.btns[tool].classList.add('active');
            ui.workspace.style.cursor = tool === 'text' || tool === 'link' ? 'text' : (tool === 'cursor' ? 'default' : 'crosshair');
            if (tool !== 'cursor') clearSelection();
        }

        function adjustZoom(delta) {
            let newScale = parseFloat((state.scale + delta).toFixed(1));
            if(newScale < 0.5) newScale = 0.5;
            if(newScale > 3.0) newScale = 3.0;
            state.scale = newScale;
            ui.zoomSlider.value = newScale;
            ui.zoomLabel.innerText = Math.round(newScale * 100) + '%';
            debouncedRender();
        }

        // Debounce render to prevent lag on zoom drag
        let renderTimeout;
        function debouncedRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                renderAllPages();
            }, 100);
        }

        // --- PDF Logic ---

        async function loadPDF(file, reset = false) {
            if (!file) return;
            ui.loader.classList.remove('hidden');

            try {
                const buffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(buffer).promise;
                
                // Register this document instance so we can find it again after Undo
                const docRefId = 'doc-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                pdf.refId = docRefId;
                docRegistry[docRefId] = pdf;

                if (reset) {
                    state.pages = [];
                    state.elements = []; 
                    state.history = [];
                    state.historyIndex = -1;
                }

                const numPages = pdf.numPages;

                for (let i = 1; i <= numPages; i++) {
                    state.pages.push({
                        pdfDocRef: docRefId, // Store reference string, not heavy object
                        pageIndex: i,
                        id: `page-${Date.now()}-${i}` // Unique ID for this specific visual page
                    });
                }

                await renderAllPages();
                
                if (reset) {
                    pushHistory(); 
                }
                
            } catch(err) {
                alert("Error loading PDF");
                console.error(err);
            } finally {
                ui.loader.classList.add('hidden');
            }
        }

        // --- Insert PDF Logic ---

        async function prepareInsert(file) {
            if (!file) return;
            ui.loader.classList.remove('hidden');
            
            try {
                const buffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(buffer).promise;
                const docRefId = 'ins-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                pdf.refId = docRefId;
                docRegistry[docRefId] = pdf;

                state.tempInsertPdf = { refId: docRefId, doc: pdf };
                state.tempInsertPageCount = pdf.numPages;
                
                ui.loader.classList.add('hidden');
                
                ui.insertInput.value = state.totalVisualPages; 
                ui.insertInput.max = state.totalVisualPages; 
                ui.modal.style.display = 'flex';
                
            } catch(err) {
                alert("Error preparing insertion");
                ui.loader.classList.add('hidden');
            }
        }

        function closeModal() {
            ui.modal.style.display = 'none';
            state.tempInsertPdf = null;
            document.getElementById('file-insert').value = ''; 
        }

        async function confirmInsert() {
            const insertIndex = parseInt(ui.insertInput.value) - 1; // Convert to 0-based index
            if (isNaN(insertIndex) || insertIndex < 0) insertAt = 0;

            ui.modal.style.display = 'none';
            ui.loader.classList.remove('hidden');

            const { refId, doc } = state.tempInsertPdf;
            const count = state.tempInsertPageCount;

            // Create new page entries
            const newPageEntries = [];
            for (let i = 1; i <= count; i++) {
                newPageEntries.push({
                    pdfDocRef: refId,
                    pageIndex: i,
                    id: `page-${Date.now()}-${i}`
                });
            }

            // Insert into state.pages array
            state.pages.splice(insertIndex, 0, ...newPageEntries);
            
            await renderAllPages();
            ui.loader.classList.add('hidden');
            
            state.tempInsertPdf = null;
            document.getElementById('file-insert').value = '';
            pushHistory();
        }

        // --- Rendering ---
        
        // Helper to preserve scroll
        let savedScrollTop = 0;

        async function renderAllPages() {
            savedScrollTop = ui.workspace.scrollTop;
            state.totalVisualPages = state.pages.length;
            ui.thumbContainer.innerHTML = '';
            
            // Keep the marquee and loader
            ui.workspace.innerHTML = '<div id="loader" class="hidden">Loading PDF...</div><div id="marquee-box"></div>';
            ui.marquee = document.getElementById('marquee-box');

            const promises = [];
            
            for (let i = 0; i < state.pages.length; i++) {
                const pageRef = state.pages[i];
                // Get actual pdf object from registry
                const pdfDoc = docRegistry[pageRef.pdfDocRef];
                if(pdfDoc) {
                    promises.push(renderSinglePage(i + 1, pageRef, pdfDoc));
                }
            }

            try {
                const results = await Promise.all(promises);
                results.forEach(res => {
                    ui.thumbContainer.appendChild(res.thumb);
                    ui.workspace.appendChild(res.dom);
                });
                
                // Restore Scroll
                ui.workspace.scrollTop = savedScrollTop;
                
                checkPageVisible();
            } catch (e) {
                console.error("Render Error", e);
            }
        }

        async function renderSinglePage(visualNum, pageRef, pdfDoc) {
            const page = await pdfDoc.getPage(pageRef.pageIndex);
            const viewport = page.getViewport({ scale: state.scale });
            
            // 1. Main Page Wrapper
            const wrapper = document.createElement('div');
            wrapper.className = 'page';
            wrapper.style.width = `${viewport.width}px`;
            wrapper.style.height = `${viewport.height}px`;
            wrapper.dataset.pageId = pageRef.id; // Use ID, not number
            wrapper.dataset.visualNum = visualNum; // Keep number for display logic

            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
            wrapper.appendChild(canvas);

            // 2. Render Annotations for this page ID (Changed from number to ID)
            const pageElements = state.elements.filter(el => el.pageId === pageRef.id);
            pageElements.forEach(el => {
                wrapper.appendChild(createDOM(el));
            });

            // 3. Thumbnail
            const thumb = document.createElement('div');
            thumb.className = 'thumb';
            thumb.draggable = true;
            thumb.dataset.visualIndex = visualNum - 1;
            
            // Highlight current page
            const currentPageId = ui.pageLabel.getAttribute('data-active-id');
            if (currentPageId === pageRef.id) thumb.classList.add('active');
            else thumb.classList.remove('active');

            thumb.onclick = (e) => {
                if(state.draggedPageVisualIndex === null) {
                    const wrapper = document.querySelector(`.page[data-page-id="${pageRef.id}"]`);
                    if(wrapper) wrapper.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            };
            
            // Drag Events
            thumb.addEventListener('dragstart', (e) => {
                state.draggedPageVisualIndex = parseInt(thumb.dataset.visualIndex);
                thumb.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                // Set data for firefox compatibility
                e.dataTransfer.setData('text/plain', thumb.dataset.visualIndex);
            });
            
            thumb.addEventListener('dragend', () => {
                thumb.classList.remove('dragging');
                state.draggedPageVisualIndex = null;
                // Cleanup visual states
                Array.from(ui.thumbContainer.children).forEach(c => c.classList.remove('drag-over'));
            });

            // We handle the scroll logic on the CONTAINER, so we don't need it here.
            // We just need the visual feedback here.
            thumb.addEventListener('dragover', (e) => {
                e.preventDefault(); 
                // e.dataTransfer.dropEffect = 'move'; // Optional, sometimes causes cursor flicker
                thumb.classList.add('drag-over');
            });
            
            thumb.addEventListener('dragenter', (e) => {
                thumb.classList.add('drag-over');
            });
            
            thumb.addEventListener('dragleave', (e) => {
                thumb.classList.remove('drag-over');
            });

            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                const fromIndex = state.draggedPageVisualIndex;
                const toIndex = parseInt(thumb.dataset.visualIndex);
                if (fromIndex !== null && fromIndex !== toIndex) {
                    movePage(fromIndex, toIndex);
                }
            });

            const thumbCanvas = document.createElement('canvas');
            const thumbVp = page.getViewport({ scale: 0.15 }); // Thumbnail scale constant
            thumbCanvas.width = thumbVp.width;
            thumbCanvas.height = thumbVp.height;
            await page.render({ canvasContext: thumbCanvas.getContext('2d'), viewport: thumbVp }).promise;
            
            thumb.appendChild(thumbCanvas);
            thumb.appendChild(document.createElement('br'));
            const label = document.createElement('div');
            label.className = 'thumb-page-num';
            label.innerText = `Page ${visualNum}`;
            thumb.appendChild(label);
            
            return { dom: wrapper, thumb: thumb };
        }

        function checkPageVisible() {
            const center = ui.workspace.getBoundingClientRect().top + (ui.workspace.clientHeight / 2);
            const pages = document.querySelectorAll('.page');
            let found = false;
            pages.forEach(p => {
                const r = p.getBoundingClientRect();
                if (r.top <= center && r.bottom >= center) {
                    const pageNum = parseInt(p.dataset.visualNum);
                    const pageId = p.dataset.pageId;
                    
                    if (state.currentPage !== pageNum) {
                        state.currentPage = pageNum;
                        ui.pageLabel.innerText = `Page ${pageNum}`;
                        ui.pageLabel.setAttribute('data-active-id', pageId);
                        
                        // Update Sidebar Highlight
                        document.querySelectorAll('.thumb').forEach(t => t.classList.remove('active'));
                        // Find thumb with matching visual index logic
                        const thumbs = Array.from(ui.thumbContainer.children);
                        if(thumbs[pageNum-1]) thumbs[pageNum-1].classList.add('active');
                        
                        found = true;
                    }
                }
            });
        }

        // --- Page Reordering Logic (Improved) ---
        function movePage(fromIndex, toIndex) {
            // 1. Move the page object in the array
            // We use Splice: Remove from 'from', Insert at 'to'
            const pageToMove = state.pages[fromIndex];
            state.pages.splice(fromIndex, 1);
            state.pages.splice(toIndex, 0, pageToMove);

            // 2. Re-render
            renderAllPages();
            pushHistory();
        }

        // --- Helper: Hex to RGBA ---
        function applyOpacity(hex, opacity) {
            if (!hex || hex === 'transparent' || opacity === 1) return hex;
            hex = hex.replace('#', '');
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        // --- DOM Creation ---
        function createDOM(el) {
            const div = document.createElement('div');
            div.className = `annotation type-${el.type}`;
            if (state.selections.some(s => s.id === el.id)) div.classList.add('selected');
            
            div.style.left = el.x + 'px';
            div.style.top = el.y + 'px';
            div.style.width = el.w + 'px';
            div.style.height = el.h + 'px';
            div.id = el.id;

            if (el.type === 'text' || el.type === 'link') {
                div.style.fontSize = (el.fontSize || 16) + 'px';
                div.style.color = (el.color || (el.type === 'link' ? 'blue' : '#000000'));
                div.style.borderWidth = (el.borderWidth || 0) + 'px';
                div.style.borderColor = (el.borderColor || 'transparent');
                div.style.borderStyle = 'solid';
                
                const opacity = (el.fillOpacity !== undefined) ? el.fillOpacity : 1;
                div.style.backgroundColor = applyOpacity(el.fillColor || 'transparent', opacity);
            } else if (el.type === 'rect') {
                div.style.borderWidth = (el.borderWidth || (el.type === 'rect' ? 2 : 1)) + 'px';
                div.style.borderColor = (el.borderColor || (el.type === 'rect' ? '#007acc' : '#000000'));
                div.style.borderStyle = 'solid';
                
                const opacity = (el.fillOpacity !== undefined) ? el.fillOpacity : (el.type === 'rect' ? 0.2 : 0);
                div.style.backgroundColor = applyOpacity(el.fillColor || (el.type === 'rect' ? '#007acc' : 'transparent'), opacity);
            }

            if (el.type === 'text' || el.type === 'link') {
                let displayContent = el.content;
                if (el.type === 'text' && (!displayContent || displayContent.trim() === '')) {
                    displayContent = '<span class="placeholder">Type here...</span>';
                }

                div.innerHTML = `<div class="text-content" contenteditable="true">${displayContent}</div>`;
                const content = div.querySelector('.text-content');
                
                content.addEventListener('focus', () => {
                    if (content.innerText === 'Type here...') content.innerText = '';
                });
                content.addEventListener('blur', () => {
                    el.content = content.innerText;
                    if (el.type === 'text' && (!el.content || el.content.trim() === '')) {
                        content.innerHTML = '<span class="placeholder">Type here...</span>';
                    }
                    pushHistory();
                });
                content.addEventListener('input', () => {
                    const textArea = document.getElementById('prop-text');
                    if (textArea && state.selections.length === 1 && state.selections[0].id === el.id) {
                        textArea.value = content.innerText;
                    }
                });
                content.addEventListener('mousedown', e => {
                    if (document.activeElement === content) e.stopPropagation();
                });
            }

            if (el.type === 'link') {
                div.title = `Link: ${el.linkType === 'url' ? el.targetUrl : 'Page ' + el.targetPage}`;
                div.onclick = (e) => {
                    e.stopPropagation();
                    if (el.linkType === 'url') {
                        window.open(el.targetUrl, '_blank');
                    } else {
                        // Find visual index of target page ID
                        const targetIdx = state.pages.findIndex(p => p.id === el.targetPageId);
                        if(targetIdx > -1) {
                            const wrapper = document.querySelectorAll('.page')[targetIdx];
                            if(wrapper) wrapper.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                };
            }

            if (el.type === 'rect' || el.type === 'text' || el.type === 'link') {
                ['nw', 'ne', 'sw', 'se'].forEach(dir => {
                    const h = document.createElement('div');
                    h.className = `resize-handle`;
                    h.style.cursor = `${dir}-resize`;
                    h.style[dir.includes('n') ? 'top' : 'bottom'] = '-5px';
                    h.style[dir.includes('w') ? 'left' : 'right'] = '-5px';
                    h.dataset.dir = dir;
                    div.appendChild(h);
                });
            }

            return div;
        }

        // --- Interaction Engine ---

        function onMouseDown(e) {
            const target = e.target;
            const pageWrapper = target.closest('.page');
            if (!pageWrapper) return;

            // Use Page ID now
            const pageId = pageWrapper.dataset.pageId;
            const rect = pageWrapper.getBoundingClientRect();

            if (target.classList.contains('resize-handle')) {
                const elDiv = target.closest('.annotation');
                const elData = state.elements.find(x => x.id === elDiv.id);
                if (!state.selections.some(s => s.id === elData.id)) {
                    selectElement(elData.id);
                }
                startResize(e, target.dataset.dir);
                return;
            }

            const elDiv = target.closest('.annotation');
            if (elDiv) {
                const id = elDiv.id;
                const elData = state.elements.find(x => x.id === id);
                
                if ((state.tool === 'text' || state.tool === 'link') && !state.isDrawing) {
                    const content = elDiv.querySelector('.text-content');
                    setTimeout(() => content.focus(), 0);
                    selectElement(id);
                    return;
                }

                if (state.tool === 'cursor') {
                    if (!e.shiftKey && !state.selections.some(s => s.id === id)) {
                        selectElement(id); 
                    } else if (e.shiftKey) {
                        toggleSelection(id); 
                    }
                    startDrag(e);
                    return;
                }

                return;
            }

            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (state.tool === 'cursor') {
                startMarquee(e);
                clearSelection(); 
            } else if (['rect', 'link', 'text'].includes(state.tool)) {
                startDrawing(e, pageId, x, y);
            }
        }

        function onMouseMove(e) {
            if (state.isResizing) updateResize(e);
            else if (state.isDragging) updateDrag(e);
            else if (state.isMarquee) updateMarquee(e);
            else if (state.isDrawing) updateDrawing(e);
        }

        function onMouseUp(e) {
            if (state.isResizing) finishResize();
            else if (state.isDragging) finishDrag();
            else if (state.isMarquee) finishMarquee();
            else if (state.isDrawing) finishDrawing();
        }

        // --- Marquee Logic ---
        function startMarquee(e) {
            state.isMarquee = true;
            state.marqueeStart = { x: e.clientX, y: e.clientY };
            
            ui.marquee.style.display = 'block';
            ui.marquee.style.left = e.clientX + 'px';
            ui.marquee.style.top = e.clientY + 'px';
            ui.marquee.style.width = '0px';
            ui.marquee.style.height = '0px';
        }

        function updateMarquee(e) {
            const start = state.marqueeStart;
            const width = Math.abs(e.clientX - start.x);
            const height = Math.abs(e.clientY - start.y);
            const left = Math.min(e.clientX, start.x);
            const top = Math.min(e.clientY, start.y);

            ui.marquee.style.width = width + 'px';
            ui.marquee.style.height = height + 'px';
            ui.marquee.style.left = left + 'px';
            ui.marquee.style.top = top + 'px';

            const marqueeRect = { l: left, t: top, r: left + width, b: top + height };
            const allEls = document.querySelectorAll('.annotation');
            allEls.forEach(dom => {
                const r = dom.getBoundingClientRect();
                const isHit = !(marqueeRect.r < r.left || marqueeRect.l > r.right || marqueeRect.b < r.top || marqueeRect.t > r.bottom);
                
                if (isHit) {
                    const id = dom.id;
                    if (!state.selections.some(s => s.id === id)) addToSelection(id);
                } else {
                    const id = dom.id;
                    if (state.selections.some(s => s.id === id)) removeFromSelection(id);
                }
            });
        }

        function finishMarquee() {
            state.isMarquee = false;
            ui.marquee.style.display = 'none';
            renderPropPanel();
        }

        // --- Selection Management ---
        function clearSelection() {
            state.selections.forEach(s => {
                const dom = document.getElementById(s.id);
                if (dom) dom.classList.remove('selected');
            });
            state.selections = [];
            renderPropPanel();
        }

        function selectElement(id) {
            clearSelection();
            addToSelection(id);
        }

        function toggleSelection(id) {
            if (state.selections.some(s => s.id === id)) removeFromSelection(id);
            else addToSelection(id);
            renderPropPanel();
        }

        function addToSelection(id) {
            const el = state.elements.find(x => x.id === id);
            const dom = document.getElementById(id);
            if (el && dom) {
                state.selections.push({ id, element: el, dom });
                dom.classList.add('selected');
            }
            renderPropPanel();
        }

        function removeFromSelection(id) {
            const idx = state.selections.findIndex(s => s.id === id);
            if (idx > -1) {
                state.selections.splice(idx, 1);
                const dom = document.getElementById(id);
                if (dom) dom.classList.remove('selected');
            }
            renderPropPanel();
        }

        // --- Drag Logic (Multi) ---
        function startDrag(e) {
            state.isDragging = true;
            state.startPos = { x: e.clientX, y: e.clientY };
            state.initialEls = state.selections.map(s => ({ id: s.id, x: s.element.x, y: s.element.y }));
        }

        function updateDrag(e) {
            const dx = e.clientX - state.startPos.x;
            const dy = e.clientY - state.startPos.y;
            
            state.initialEls.forEach(init => {
                const sel = state.selections.find(s => s.id === init.id);
                if (!sel) return;
                
                sel.element.x = init.x + dx;
                sel.element.y = init.y + dy;
                
                sel.dom.style.left = sel.element.x + 'px';
                sel.dom.style.top = sel.element.y + 'px';
            });

            if (state.selections.length === 1) updatePropInputs(state.selections[0].element);
        }

        function finishDrag() {
            state.isDragging = false;
            pushHistory();
        }

        // --- Resize Logic ---
        function startResize(e, dir) {
            state.isResizing = true;
            state.resizeHandle = dir;
            state.startPos = { x: e.clientX, y: e.clientY };
            const el = state.selections[0].element;
            state.initialEls = [{ id: el.id, x: el.x, y: el.y, w: el.w, h: el.h }];
        }

        function updateResize(e) {
            const dx = e.clientX - state.startPos.x;
            const dy = e.clientY - state.startPos.y;
            const dir = state.resizeHandle;
            const init = state.initialEls[0];
            
            let nx = init.x, ny = init.y, nw = init.w, nh = init.h;

            if (dir.includes('e')) nw = Math.max(10, init.w + dx);
            if (dir.includes('s')) nh = Math.max(10, init.h + dy);
            if (dir.includes('w')) { nw = Math.max(10, init.w - dx); nx = init.x + dx; }
            if (dir.includes('n')) { nh = Math.max(10, init.h - dy); ny = init.y + dy; }

            const el = state.selections[0].element;
            el.x = nx; el.y = ny; el.w = nw; el.h = nh;

            state.selections[0].dom.style.left = nx + 'px';
            state.selections[0].dom.style.top = ny + 'px';
            state.selections[0].dom.style.width = nw + 'px';
            state.selections[0].dom.style.height = nh + 'px';
            
            updatePropInputs(el);
        }

        function finishResize() {
            state.isResizing = false;
            pushHistory();
        }

        // --- Drawing Logic ---
        function startDrawing(e, pageId, x, y) {
            state.isDrawing = true;
            state.drawStart = { x, y };
            state.drawPageId = pageId; // Use Page ID
            
            const defaults = {
                id: 'el-' + Date.now(),
                type: state.tool,
                pageId: pageId, // Changed from 'page' to 'pageId'
                x: x, y: y,
                w: 0, h: 0,
                content: ''
            };

            if (state.tool === 'text') {
                defaults.fontSize = 16;
                defaults.color = '#000000';
                defaults.borderWidth = 0;
                defaults.borderColor = 'transparent';
                defaults.fillColor = 'transparent';
                defaults.fillOpacity = 1;
            } else if (state.tool === 'rect') {
                defaults.borderWidth = 2;
                defaults.borderColor = '#007acc';
                defaults.fillColor = '#007acc'; 
                defaults.fillOpacity = 0.2;     
            } else if (state.tool === 'link') {
                defaults.fontSize = 16;
                defaults.color = 'blue';
                defaults.borderWidth = 1;
                defaults.borderColor = 'black';
                defaults.fillColor = 'transparent';
                defaults.fillOpacity = 0;
                defaults.linkType = 'page'; 
                defaults.targetPageId = pageId; // Default link to same page
                defaults.targetUrl = 'https://';
                defaults.content = ''; 
            }

            state.elements.push(defaults);
            
            const wrapper = document.querySelector(`.page[data-page-id="${pageId}"]`);
            if(wrapper) {
                wrapper.appendChild(createDOM(defaults));
                state.currentDrawId = defaults.id;
                selectElement(defaults.id); 
            }
        }

        function updateDrawing(e) {
            const wrapper = document.querySelector(`.page[data-page-id="${state.drawPageId}"]`);
            if(!wrapper) return;
            const rect = wrapper.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const el = state.elements.find(x => x.id === state.currentDrawId);
            if(!el) return;

            const sx = state.drawStart.x;
            const sy = state.drawStart.y;

            el.x = Math.min(sx, mx);
            el.y = Math.min(sy, my);
            el.w = Math.abs(mx - sx);
            el.h = Math.abs(my - sy);
            
            if (el.type === 'text' || el.type === 'link') {
                if (el.w < 100) el.w = 100;
                if (el.h < 30) el.h = 30;
            }

            const dom = document.getElementById(el.id);
            if (dom) {
                dom.style.left = el.x + 'px';
                dom.style.top = el.y + 'px';
                dom.style.width = el.w + 'px';
                dom.style.height = el.h + 'px';
            }
            updatePropInputs(el);
        }

        function finishDrawing() {
            state.isDrawing = false;
            const el = state.elements.find(x => x.id === state.currentDrawId);
            
            if (el.w < 5 && el.h < 5 && el.type !== 'text' && el.type !== 'link') {
                state.elements = state.elements.filter(x => x.id !== el.id);
                const dom = document.getElementById(el.id);
                if(dom) dom.remove();
                clearSelection();
            } else if (el.type === 'text' || el.type === 'link') {
                const dom = document.getElementById(el.id);
                if(dom) {
                    const content = dom.querySelector('.text-content');
                    setTimeout(() => content.focus(), 0);
                }
            }
            pushHistory();
        }

        // --- Properties Panel (Extended) ---
        function renderPropPanel() {
            const panel = ui.props;
            panel.innerHTML = '';

            if (state.selections.length === 0) {
                panel.innerHTML = '<div class="empty-state">No Element Selected</div>';
                return;
            }

            if (state.selections.length > 1) {
                panel.innerHTML = '<div class="empty-state">Multiple Elements Selected</div>';
                return;
            }

            const el = state.selections[0].element;

            // 1. Geometry
            panel.innerHTML += `
                <div class="prop-row inputs-bottom">
                    <div class="prop-group"><label>X</label><input type="number" id="prop-x" value="${Math.round(el.x)}"></div>
                    <div class="prop-group"><label>Y</label><input type="number" id="prop-y" value="${Math.round(el.y)}"></div>
                </div>
                <div class="prop-row inputs-bottom">
                    <div class="prop-group"><label>W</label><input type="number" id="prop-w" value="${Math.round(el.w)}"></div>
                    <div class="prop-group"><label>H</label><input type="number" id="prop-h" value="${Math.round(el.h)}"></div>
                </div>
            `;

            // 2. Style Properties
            if (el.type === 'text' || el.type === 'link') {
                panel.innerHTML += `<div style="height:1px; background:var(--border); margin: 5px 0;"></div>`;
                
                panel.innerHTML += `
                    <div class="prop-row inputs-bottom">
                        <div class="prop-group"><label>Font Size</label><input type="number" id="prop-fs" value="${el.fontSize || 16}"></div>
                        <div class="prop-group"><label>Text Color</label><input type="color" id="prop-tc" value="${hexFromStyle(el.color, '#000000')}"></div>
                    </div>
                `;
            }
            if (['rect', 'link', 'text'].includes(el.type)) {
                panel.innerHTML += `<div style="height:1px; background:var(--border); margin: 5px 0;"></div>`;
                
                panel.innerHTML += `
                    <div class="prop-row inputs-bottom">
                        <div class="prop-group"><label>Border Width</label><input type="number" id="prop-bw" value="${el.borderWidth || 0}"></div>
                        <div class="prop-group"><label>Border Color</label><input type="color" id="prop-bc" value="${hexFromStyle(el.borderColor, (el.type === 'rect' ? '#007acc' : '#000000'))}"></div>
                    </div>
                `;
                
                const defaultFill = (el.type === 'rect' ? '#007acc' : (el.type === 'link' ? '#ffffff' : '#ffffff'));
                panel.innerHTML += `
                    <div class="prop-row inputs-bottom">
                         <div class="prop-group"><label>Fill Color</label><input type="color" id="prop-fc" value="${hexFromStyle(el.fillColor, defaultFill)}"></div>
                         <div class="prop-group"><label>Fill Opacity</label><input type="range" id="prop-fo" min="0" max="1" step="0.05" value="${el.fillOpacity !== undefined ? el.fillOpacity : (el.type === 'rect' ? 0.2 : 0)}"></div>
                    </div>
                `;
            }

            // 3. Specific Properties
            if (el.type === 'text' || el.type === 'link') {
                panel.innerHTML += `<div style="height:1px; background:var(--border); margin: 5px 0;"></div>`;
                panel.innerHTML += `
                    <div class="prop-group">
                        <label>Content</label>
                        <textarea id="prop-text" placeholder="Enter text here...">${el.content}</textarea>
                    </div>
                `;
            }
            if (el.type === 'link') {
                panel.innerHTML += `<div style="height:1px; background:var(--border); margin: 5px 0;"></div>`;
                
                const currentType = el.linkType || 'page';
                panel.innerHTML += `
                    <div class="prop-group">
                        <label>Link Type</label>
                        <select id="prop-link-type">
                            <option value="page" ${currentType === 'page' ? 'selected' : ''}>Page (Internal)</option>
                            <option value="url" ${currentType === 'url' ? 'selected' : ''}>URL (External)</option>
                        </select>
                    </div>
                `;

                if (currentType === 'page') {
                    // Get visual page number from ID
                    const targetIdx = state.pages.findIndex(p => p.id === el.targetPageId);
                    const visualNum = targetIdx > -1 ? targetIdx + 1 : 1;
                    
                    panel.innerHTML += `
                        <div class="prop-group" id="prop-page-group">
                            <label>Target Page</label>
                            <input type="number" id="prop-page" value="${visualNum}" min="1" max="${state.pages.length}">
                        </div>
                    `;
                } else {
                    panel.innerHTML += `
                        <div class="prop-group" id="prop-url-group">
                            <label>Target URL</label>
                            <input type="text" id="prop-url" value="${el.targetUrl || 'https://'}">
                        </div>
                    `;
                }
            }

            // 4. Actions
            const btn = document.createElement('button');
            btn.style.background = '#d94444';
            btn.style.color = 'white';
            btn.style.marginTop = '20px';
            btn.innerText = 'Delete Element';
            btn.onclick = deleteSelections;
            panel.appendChild(btn);

            // Bind Events
            bindGeometryEvents();
            
            if (el.type === 'text' || el.type === 'link') {
                bindStyleEvents('fs', 'fontSize', 'px');
                bindColorEvents('tc', 'color');
            }
            if (['rect', 'link', 'text'].includes(el.type)) {
                bindStyleEvents('bw', 'borderWidth', 'px');
                bindColorEvents('bc', 'borderColor');
                bindColorEvents('fc', 'fillColor');
                bindOpacityEvents('fo', 'fillOpacity');
            }

            if (el.type === 'text' || el.type === 'link') {
                const t = document.getElementById('prop-text');
                t.addEventListener('input', (e) => {
                    el.content = e.target.value;
                    const dom = document.querySelector(`#${el.id} .text-content`);
                    if (dom) dom.innerText = e.target.value;
                });
                t.addEventListener('change', () => { pushHistory(); });
            }

            if (el.type === 'link') {
                const typeSelect = document.getElementById('prop-link-type');
                typeSelect.addEventListener('change', (e) => {
                    el.linkType = e.target.value;
                    renderPropPanel(); 
                    const dom = document.getElementById(el.id);
                    dom.style.backgroundColor = applyOpacity(el.fillColor || 'transparent', el.fillOpacity || 0);
                });

                if (el.linkType === 'page') {
                    const p = document.getElementById('prop-page');
                    p.addEventListener('change', (e) => {
                        const visualNum = parseInt(e.target.value) - 1;
                        if(state.pages[visualNum]) {
                            el.targetPageId = state.pages[visualNum].id;
                            pushHistory();
                        }
                    });
                } else {
                    const u = document.getElementById('prop-url');
                    u.addEventListener('change', (e) => {
                        el.targetUrl = e.target.value;
                        pushHistory();
                    });
                }
            }
        }

        // Helper to bind generic style changes
        function bindStyleEvents(idSuffix, prop, unit) {
            const input = document.getElementById(`prop-${idSuffix}`);
            if (!input) return;
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                state.selections[0].element[prop] = val;
                state.selections[0].dom.style[prop] = val + unit;
            });
            input.addEventListener('change', pushHistory);
        }

        function bindColorEvents(idSuffix, prop) {
            const input = document.getElementById(`prop-${idSuffix}`);
            if (!input) return;
            input.addEventListener('input', (e) => {
                const val = e.target.value;
                state.selections[0].element[prop] = val;
                if (prop === 'fillColor') {
                    const el = state.selections[0].element;
                    const op = el.fillOpacity !== undefined ? el.fillOpacity : 1;
                    state.selections[0].dom.style.backgroundColor = applyOpacity(val, op);
                } else {
                    state.selections[0].dom.style[prop] = val;
                }
            });
            input.addEventListener('change', pushHistory);
        }

        function bindOpacityEvents(idSuffix, prop) {
            const input = document.getElementById(`prop-${idSuffix}`);
            if (!input) return;
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                state.selections[0].element[prop] = val;
                const el = state.selections[0].element;
                const color = el.fillColor || (el.type === 'rect' ? '#007acc' : '#ffffff');
                state.selections[0].dom.style.backgroundColor = applyOpacity(color, val);
            });
            input.addEventListener('change', pushHistory);
        }

        function bindGeometryEvents() {
            ['x', 'y', 'w', 'h'].forEach(k => {
                const input = document.getElementById(`prop-${k}`);
                if (!input) return;
                input.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.selections[0].element[k] = val;
                    const dom = state.selections[0].dom;
                    if (k === 'x') dom.style.left = val + 'px';
                    if (k === 'y') dom.style.top = val + 'px';
                    if (k === 'w' || k === 'h') dom.style[k === 'w' ? 'width' : 'height'] = val + 'px';
                });
                input.addEventListener('change', pushHistory);
            });
        }

        function updatePropInputs(el) {
            const setVal = (id, v) => {
                const input = document.getElementById(id);
                if (input) input.value = Math.round(v);
            };
            setVal('prop-x', el.x);
            setVal('prop-y', el.y);
            setVal('prop-w', el.w);
            setVal('prop-h', el.h);
        }

        // Helper: Convert rgba/rgb to Hex
        function hexFromStyle(colorStr, defaultHex) {
            if (!colorStr || colorStr === 'transparent') return defaultHex;
            if (colorStr.startsWith('#')) return colorStr;
            
            const rgb = colorStr.match(/\d+/g);
            if (rgb && rgb.length >= 3) {
                return "#" + ((1 << 24) + (parseInt(rgb[0]) << 16) + (parseInt(rgb[1]) << 8) + parseInt(rgb[2])).toString(16).slice(1);
            }
            return defaultHex;
        }

        function deleteSelections() {
            state.selections.forEach(s => {
                const dom = document.getElementById(s.id);
                if (dom) dom.remove();
                state.elements = state.elements.filter(x => x.id !== s.id);
            });
            clearSelection();
            pushHistory();
        }

        // --- History (Fixed for PDF.js Objects) ---
        function pushHistory() {
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            
            // Create a lightweight snapshot of pages (only IDs and Refs, not the heavy object)
            const pagesSnapshot = state.pages.map(p => ({
                id: p.id,
                pdfDocRef: p.pdfDocRef,
                pageIndex: p.pageIndex
            }));

            // Deep clone elements (safe)
            const elementsSnapshot = JSON.parse(JSON.stringify(state.elements));

            state.history.push({ pages: pagesSnapshot, elements: elementsSnapshot });
            state.historyIndex++;
            if (state.history.length > 20) {
                state.history.shift();
                state.historyIndex--;
            }
        }

        function undo() {
            if (state.historyIndex <= 0) return;
            state.historyIndex--;
            restoreState(state.history[state.historyIndex]);
        }

        function redo() {
            if (state.historyIndex >= state.history.length - 1) return;
            state.historyIndex++;
            restoreState(state.history[state.historyIndex]);
        }

        function restoreState(data) {
            // Rehydrate pages from registry
            state.pages = data.pages.map(p => ({
                id: p.id,
                pdfDocRef: p.pdfDocRef,
                pageIndex: p.pageIndex
                // pdfDoc will be looked up during render using docRegistry
            }));
            state.elements = data.elements;
            
            refreshAll();
            clearSelection();
        }

        function refreshAll() {
            // We just call renderAllPages which handles clearing the DOM and rebuilding
            renderAllPages();
        }

        function app() {} 
        app.exportData = () => {
            const str = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({ pages: state.pages, elements: state.elements }));
            const a = document.createElement('a');
            a.href = str;
            a.download = "project_data.json";
            document.body.appendChild(a);
            a.click();
            a.remove();
        };

    </script>
</body>
</html>